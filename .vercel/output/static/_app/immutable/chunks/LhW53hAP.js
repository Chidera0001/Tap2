const b="1.28.0";var d=[],u=[],Y=Uint8Array,F="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var y=0,Z=F.length;y<Z;++y)d[y]=F[y],u[F.charCodeAt(y)]=y;u[45]=62;u[95]=63;function K(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");r===-1&&(r=t);var n=r===t?0:4-r%4;return[r,n]}function ee(e,t,r){return(t+r)*3/4-r}function L(e){var t,r=K(e),n=r[0],o=r[1],i=new Y(ee(e,n,o)),a=0,c=o>0?n-4:n,s;for(s=0;s<c;s+=4)t=u[e.charCodeAt(s)]<<18|u[e.charCodeAt(s+1)]<<12|u[e.charCodeAt(s+2)]<<6|u[e.charCodeAt(s+3)],i[a++]=t>>16&255,i[a++]=t>>8&255,i[a++]=t&255;return o===2&&(t=u[e.charCodeAt(s)]<<2|u[e.charCodeAt(s+1)]>>4,i[a++]=t&255),o===1&&(t=u[e.charCodeAt(s)]<<10|u[e.charCodeAt(s+1)]<<4|u[e.charCodeAt(s+2)]>>2,i[a++]=t>>8&255,i[a++]=t&255),i}function te(e){return d[e>>18&63]+d[e>>12&63]+d[e>>6&63]+d[e&63]}function re(e,t,r){for(var n,o=[],i=t;i<r;i+=3)n=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255),o.push(te(n));return o.join("")}function O(e){for(var t,r=e.length,n=r%3,o=[],i=16383,a=0,c=r-n;a<c;a+=i)o.push(re(e,a,a+i>c?c:a+i));return n===1?(t=e[r-1],o.push(d[t>>2]+d[t<<4&63]+"==")):n===2&&(t=(e[r-2]<<8)+e[r-1],o.push(d[t>>10]+d[t>>4&63]+d[t<<2&63]+"=")),o.join("")}function $(e){if(e===void 0)return{};if(!Q(e))throw new Error(`The arguments to a Convex function must be an object. Received: ${e}`);return e}function ne(e){if(typeof e>"u")throw new Error("Client created with undefined deployment address. If you used an environment variable, check that it's set.");if(typeof e!="string")throw new Error(`Invalid deployment address: found ${e}".`);if(!(e.startsWith("http:")||e.startsWith("https:")))throw new Error(`Invalid deployment address: Must start with "https://" or "http://". Found "${e}".`);try{new URL(e)}catch{throw new Error(`Invalid deployment address: "${e}" is not a valid URL. If you believe this URL is correct, use the \`skipConvexDeploymentUrlCheck\` option to bypass this.`)}if(e.endsWith(".convex.site"))throw new Error(`Invalid deployment address: "${e}" ends with .convex.site, which is used for HTTP Actions. Convex deployment URLs typically end with .convex.cloud? If you believe this URL is correct, use the \`skipConvexDeploymentUrlCheck\` option to bypass this.`)}function Q(e){var o;const t=typeof e=="object",r=Object.getPrototypeOf(e),n=r===null||r===Object.prototype||((o=r==null?void 0:r.constructor)==null?void 0:o.name)==="Object";return t&&n}const U=!0,m=BigInt("-9223372036854775808"),D=BigInt("9223372036854775807"),S=BigInt("0"),oe=BigInt("8"),ie=BigInt("256");function k(e){return Number.isNaN(e)||!Number.isFinite(e)||Object.is(e,-0)}function se(e){e<S&&(e-=m+m);let t=e.toString(16);t.length%2===1&&(t="0"+t);const r=new Uint8Array(new ArrayBuffer(8));let n=0;for(const o of t.match(/.{2}/g).reverse())r.set([parseInt(o,16)],n++),e>>=oe;return O(r)}function ae(e){const t=L(e);if(t.byteLength!==8)throw new Error(`Received ${t.byteLength} bytes, expected 8 for $integer`);let r=S,n=S;for(const o of t)r+=BigInt(o)*ie**n,n++;return r>D&&(r+=m+m),r}function ce(e){if(e<m||D<e)throw new Error(`BigInt ${e} does not fit into a 64-bit signed integer.`);const t=new ArrayBuffer(8);return new DataView(t).setBigInt64(0,e,!0),O(new Uint8Array(t))}function fe(e){const t=L(e);if(t.byteLength!==8)throw new Error(`Received ${t.byteLength} bytes, expected 8 for $integer`);return new DataView(t.buffer).getBigInt64(0,!0)}const he=DataView.prototype.setBigInt64?ce:se,ue=DataView.prototype.getBigInt64?fe:ae,P=1024;function R(e){if(e.length>P)throw new Error(`Field name ${e} exceeds maximum field name length ${P}.`);if(e.startsWith("$"))throw new Error(`Field name ${e} starts with a '$', which is reserved.`);for(let t=0;t<e.length;t+=1){const r=e.charCodeAt(t);if(r<32||r>=127)throw new Error(`Field name ${e} has invalid character '${e[t]}': Field names can only contain non-control ASCII characters`)}}function p(e){if(e===null||typeof e=="boolean"||typeof e=="number"||typeof e=="string")return e;if(Array.isArray(e))return e.map(n=>p(n));if(typeof e!="object")throw new Error(`Unexpected type of ${e}`);const t=Object.entries(e);if(t.length===1){const n=t[0][0];if(n==="$bytes"){if(typeof e.$bytes!="string")throw new Error(`Malformed $bytes field on ${e}`);return L(e.$bytes).buffer}if(n==="$integer"){if(typeof e.$integer!="string")throw new Error(`Malformed $integer field on ${e}`);return ue(e.$integer)}if(n==="$float"){if(typeof e.$float!="string")throw new Error(`Malformed $float field on ${e}`);const o=L(e.$float);if(o.byteLength!==8)throw new Error(`Received ${o.byteLength} bytes, expected 8 for $float`);const a=new DataView(o.buffer).getFloat64(0,U);if(!k(a))throw new Error(`Float ${a} should be encoded as a number`);return a}if(n==="$set")throw new Error("Received a Set which is no longer supported as a Convex type.");if(n==="$map")throw new Error("Received a Map which is no longer supported as a Convex type.")}const r={};for(const[n,o]of Object.entries(e))R(n),r[n]=p(o);return r}function v(e){return JSON.stringify(e,(t,r)=>r===void 0?"undefined":typeof r=="bigint"?`${r.toString()}n`:r)}function j(e,t,r,n){var a;if(e===void 0){const c=r&&` (present at path ${r} in original object ${v(t)})`;throw new Error(`undefined is not a valid Convex value${c}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`)}if(e===null)return e;if(typeof e=="bigint"){if(e<m||D<e)throw new Error(`BigInt ${e} does not fit into a 64-bit signed integer.`);return{$integer:he(e)}}if(typeof e=="number")if(k(e)){const c=new ArrayBuffer(8);return new DataView(c).setFloat64(0,e,U),{$float:O(new Uint8Array(c))}}else return e;if(typeof e=="boolean"||typeof e=="string")return e;if(e instanceof ArrayBuffer)return{$bytes:O(new Uint8Array(e))};if(Array.isArray(e))return e.map((c,s)=>j(c,t,r+`[${s}]`));if(e instanceof Set)throw new Error(B(r,"Set",[...e],t));if(e instanceof Map)throw new Error(B(r,"Map",[...e],t));if(!Q(e)){const c=(a=e==null?void 0:e.constructor)==null?void 0:a.name,s=c?`${c} `:"";throw new Error(B(r,s,e,t))}const o={},i=Object.entries(e);i.sort(([c,s],[f,h])=>c===f?0:c<f?-1:1);for(const[c,s]of i)s!==void 0&&(R(c),o[c]=j(s,t,r+`.${c}`));return o}function B(e,t,r,n){return e?`${t}${v(r)} is not a supported Convex type (present at path ${e} in original object ${v(n)}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`:`${t}${v(r)} is not a supported Convex type.`}function A(e){return j(e,e,"")}var de=Object.defineProperty,le=(e,t,r)=>t in e?de(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,N=(e,t,r)=>le(e,typeof t!="symbol"?t+"":t,r),M,J;const ge=Symbol.for("ConvexError");class C extends(J=Error,M=ge,J){constructor(t){super(typeof t=="string"?t:v(t)),N(this,"name","ConvexError"),N(this,"data"),N(this,M,!0),this.data=t}}const V=()=>Array.from({length:4},()=>0);V();V();var pe=Object.defineProperty,we=(e,t,r)=>t in e?pe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,q=(e,t,r)=>we(e,typeof t!="symbol"?t+"":t,r);const ye="color:rgb(0, 145, 255)";function me(e){switch(e){case"query":return"Q";case"mutation":return"M";case"action":return"A";case"any":return"?"}}class z{constructor(t){q(this,"_onLogLineFuncs"),q(this,"_verbose"),this._onLogLineFuncs={},this._verbose=t.verbose}addLogLineListener(t){let r=Math.random().toString(36).substring(2,15);for(let n=0;n<10&&this._onLogLineFuncs[r]!==void 0;n++)r=Math.random().toString(36).substring(2,15);return this._onLogLineFuncs[r]=t,()=>{delete this._onLogLineFuncs[r]}}logVerbose(...t){if(this._verbose)for(const r of Object.values(this._onLogLineFuncs))r("debug",`${new Date().toISOString()}`,...t)}log(...t){for(const r of Object.values(this._onLogLineFuncs))r("info",...t)}warn(...t){for(const r of Object.values(this._onLogLineFuncs))r("warn",...t)}error(...t){for(const r of Object.values(this._onLogLineFuncs))r("error",...t)}}function be(e){const t=new z(e);return t.addLogLineListener((r,...n)=>{switch(r){case"debug":console.debug(...n);break;case"info":console.log(...n);break;case"warn":console.warn(...n);break;case"error":console.error(...n);break;default:console.log(...n)}}),t}function $e(e){return new z(e)}function E(e,t,r,n,o){const i=me(r);typeof o=="object"&&(o=`ConvexError ${JSON.stringify(o.errorData,null,2)}`);{const a=o.match(/^\[.*?\] /);if(a===null){e.error(`[CONVEX ${i}(${n})] Could not parse console.log`);return}const c=o.slice(1,a[0].length-2),s=o.slice(a[0].length);e.log(`%c[CONVEX ${i}(${n})] [${c}]`,ye,s)}}const T=Symbol.for("functionName"),H=Symbol.for("toReferencePath");function ve(e){return e[H]??null}function Ae(e){return e.startsWith("function://")}function Ce(e){let t;if(typeof e=="string")Ae(e)?t={functionHandle:e}:t={name:e};else if(e[T])t={name:e[T]};else{const r=ve(e);if(!r)throw new Error(`${e} is not a functionReference`);t={reference:r}}return t}function x(e){const t=Ce(e);if(t.name===void 0)throw t.functionHandle!==void 0?new Error(`Expected function reference like "api.file.func" or "internal.file.func", but received function handle ${t.functionHandle}`):t.reference!==void 0?new Error(`Expected function reference in the current component like "api.file.func" or "internal.file.func", but received reference ${t.reference}`):new Error(`Expected function reference like "api.file.func" or "internal.file.func", but received ${JSON.stringify(t)}`);if(typeof e=="string")return e;const r=e[T];if(!r)throw new Error(`${e} is not a functionReference`);return r}function W(e=[]){const t={get(r,n){if(typeof n=="string"){const o=[...e,n];return W(o)}else if(n===T){if(e.length<2){const a=["api",...e].join(".");throw new Error(`API path is expected to be of the form \`api.moduleName.functionName\`. Found: \`${a}\``)}const o=e.slice(0,-1).join("/"),i=e[e.length-1];return i==="default"?o:o+":"+i}else return n===Symbol.toStringTag?"FunctionReference":void 0}};return new Proxy({},t)}const Ee=W();var xe=Object.defineProperty,_e=(e,t,r)=>t in e?xe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,l=(e,t,r)=>_e(e,typeof t!="symbol"?t+"":t,r);const _=560;class Ie{constructor(t,r){if(l(this,"address"),l(this,"auth"),l(this,"adminAuth"),l(this,"encodedTsPromise"),l(this,"debug"),l(this,"fetchOptions"),l(this,"logger"),l(this,"mutationQueue",[]),l(this,"isProcessingQueue",!1),typeof r=="boolean")throw new Error("skipConvexDeploymentUrlCheck as the second argument is no longer supported. Please pass an options object, `{ skipConvexDeploymentUrlCheck: true }`.");(r??{}).skipConvexDeploymentUrlCheck!==!0&&ne(t),this.logger=(r==null?void 0:r.logger)===!1?$e({verbose:!1}):(r==null?void 0:r.logger)!==!0&&(r!=null&&r.logger)?r.logger:be({verbose:!1}),this.address=t,this.debug=!0,this.auth=void 0,this.adminAuth=void 0,r!=null&&r.auth&&this.setAuth(r.auth)}backendUrl(){return`${this.address}/api`}get url(){return this.address}setAuth(t){this.clearAuth(),this.auth=t}setAdminAuth(t,r){if(this.clearAuth(),r!==void 0){const n=new TextEncoder().encode(JSON.stringify(r)),o=btoa(String.fromCodePoint(...n));this.adminAuth=`${t}:${o}`}else this.adminAuth=t}clearAuth(){this.auth=void 0,this.adminAuth=void 0}setDebug(t){this.debug=t}setFetchOptions(t){this.fetchOptions=t}async consistentQuery(t,...r){const n=$(r[0]),o=this.getTimestamp();return await this.queryInner(t,n,{timestampPromise:o})}async getTimestamp(){return this.encodedTsPromise?this.encodedTsPromise:this.encodedTsPromise=this.getTimestampInner()}async getTimestampInner(){const t=fetch,r={"Content-Type":"application/json","Convex-Client":`npm-${b}`},n=await t(`${this.address}/api/query_ts`,{...this.fetchOptions,method:"POST",headers:r});if(!n.ok)throw new Error(await n.text());const{ts:o}=await n.json();return o}async query(t,...r){const n=$(r[0]);return await this.queryInner(t,n,{})}async queryInner(t,r,n){const o=x(t),i=[A(r)],a={"Content-Type":"application/json","Convex-Client":`npm-${b}`};this.adminAuth?a.Authorization=`Convex ${this.adminAuth}`:this.auth&&(a.Authorization=`Bearer ${this.auth}`);const c=fetch,s=n.timestampPromise?await n.timestampPromise:void 0,f=JSON.stringify({path:o,format:"convex_encoded_json",args:i,...s?{ts:s}:{}}),h=s?`${this.address}/api/query_at_ts`:`${this.address}/api/query`,w=await c(h,{...this.fetchOptions,body:f,method:"POST",headers:a});if(!w.ok&&w.status!==_)throw new Error(await w.text());const g=await w.json();if(this.debug)for(const G of g.logLines??[])E(this.logger,"info","query",o,G);switch(g.status){case"success":return p(g.value);case"error":throw g.errorData!==void 0?I(g.errorData,new C(g.errorMessage)):new Error(g.errorMessage);default:throw new Error(`Invalid response: ${JSON.stringify(g)}`)}}async mutationInner(t,r){const n=x(t),o=JSON.stringify({path:n,format:"convex_encoded_json",args:[A(r)]}),i={"Content-Type":"application/json","Convex-Client":`npm-${b}`};this.adminAuth?i.Authorization=`Convex ${this.adminAuth}`:this.auth&&(i.Authorization=`Bearer ${this.auth}`);const c=await fetch(`${this.address}/api/mutation`,{...this.fetchOptions,body:o,method:"POST",headers:i});if(!c.ok&&c.status!==_)throw new Error(await c.text());const s=await c.json();if(this.debug)for(const f of s.logLines??[])E(this.logger,"info","mutation",n,f);switch(s.status){case"success":return p(s.value);case"error":throw s.errorData!==void 0?I(s.errorData,new C(s.errorMessage)):new Error(s.errorMessage);default:throw new Error(`Invalid response: ${JSON.stringify(s)}`)}}async processMutationQueue(){if(!this.isProcessingQueue){for(this.isProcessingQueue=!0;this.mutationQueue.length>0;){const{mutation:t,args:r,resolve:n,reject:o}=this.mutationQueue.shift();try{const i=await this.mutationInner(t,r);n(i)}catch(i){o(i)}}this.isProcessingQueue=!1}}enqueueMutation(t,r){return new Promise((n,o)=>{this.mutationQueue.push({mutation:t,args:r,resolve:n,reject:o}),this.processMutationQueue()})}async mutation(t,...r){const[n,o]=r,i=$(n);return o!=null&&o.skipQueue?await this.mutationInner(t,i):await this.enqueueMutation(t,i)}async action(t,...r){const n=$(r[0]),o=x(t),i=JSON.stringify({path:o,format:"convex_encoded_json",args:[A(n)]}),a={"Content-Type":"application/json","Convex-Client":`npm-${b}`};this.adminAuth?a.Authorization=`Convex ${this.adminAuth}`:this.auth&&(a.Authorization=`Bearer ${this.auth}`);const s=await fetch(`${this.address}/api/action`,{...this.fetchOptions,body:i,method:"POST",headers:a});if(!s.ok&&s.status!==_)throw new Error(await s.text());const f=await s.json();if(this.debug)for(const h of f.logLines??[])E(this.logger,"info","action",o,h);switch(f.status){case"success":return p(f.value);case"error":throw f.errorData!==void 0?I(f.errorData,new C(f.errorMessage)):new Error(f.errorMessage);default:throw new Error(`Invalid response: ${JSON.stringify(f)}`)}}async function(t,r,...n){const o=$(n[0]),i=typeof t=="string"?t:x(t),a=JSON.stringify({componentPath:r,path:i,format:"convex_encoded_json",args:A(o)}),c={"Content-Type":"application/json","Convex-Client":`npm-${b}`};this.adminAuth?c.Authorization=`Convex ${this.adminAuth}`:this.auth&&(c.Authorization=`Bearer ${this.auth}`);const f=await fetch(`${this.address}/api/function`,{...this.fetchOptions,body:a,method:"POST",headers:c});if(!f.ok&&f.status!==_)throw new Error(await f.text());const h=await f.json();if(this.debug)for(const w of h.logLines??[])E(this.logger,"info","any",i,w);switch(h.status){case"success":return p(h.value);case"error":throw h.errorData!==void 0?I(h.errorData,new C(h.errorMessage)):new Error(h.errorMessage);default:throw new Error(`Invalid response: ${JSON.stringify(h)}`)}}}function I(e,t){return t.data=p(e),t}const Oe=new Ie("https://formal-penguin-443.convex.cloud");function X(e,t){const r={get(n,o){if(typeof o=="string"){const i=[...t,o];return X(e,i)}else if(o===H){if(t.length<1){const i=[e,...t].join(".");throw new Error(`API path is expected to be of the form \`${e}.childComponent.functionName\`. Found: \`${i}\``)}return"_reference/childComponent/"+t.join("/")}else return}};return new Proxy({},r)}const Le=()=>X("components",[]),Te=Ee;Le();export{Te as a,Oe as c};
